## JVM Internal Architecture

![](https://github.com/deepakmotlani/Notes/blob/master/Core%20Java/images/JVM-Architecture.png)

### Class Loader SubSystem
It is responsible for mainly 3 activities -
* Loading
* Linking
* Initialization

**Loading** - Class Loader reads .class file, generates corresponding binary data & save it in method area. For each
.class file, JVM stores following info in method area.

* Fully qualified name of loaded class & its immediate parent class.
* Whether .class is related to Class/Interface/Enum.
* Modifier, variables & method information etc.

After loading the .class file, JVM creates object of Class class to represent this file in heap. For every .class file
, only object of Class class is created.

There are 3 kinds of Loaders -
* **Bootstrap Class Loader** - Every JVM must have a bootstrap class loader, capable of loading trusted classes. It 
	loads Core Java API classes present in JAVA_HOME/jre/lib. Ex: rt.jar which contains lang package.
* **Extension Class Loader** - It is child of bootstrap loader & it loads classes from JAVA_HOME/jre/lib/ext.
* **System/Application Class Loader** - It is child of extenstion class loader & is responsible for loading classes
	from application class path.
	
**JVM follows delegation-hierarchy for loading classes. Application Class Loader delegeates to Extension which in 
	turn delegates to Bootstrap class loader. If the class is found on bootstrap path it is loaded, otherwise
	request is given back to Extension class loader & finally back to System/Application class loader. At last if
	system doesn't find the class, it throws ClassNotFoundException.**

**Linking** - Performs verification, preparation & resolution(optionally).
* Verification - It ensures correctness of .class file i.e. it checks whether file is correctly formatted & 
	generated by valid Compiler or not. If verification fails, we get runtime error i.e. java.lang.VerifyError.
* Preparation - For all static variables memory will be allocated & assigned with default values.
* Resolve - All symbolic reference are replaced with origianl reference from method area.
	
**Initialization** - All static variables are assigned with their values defined in program. All static blocks are
	executed.

### Runtime Data Area
It has 5 major components - 

* Method Area - All class level data is stored in method area, including static variables. There is only 1 method 
	area per JVM.
* Heap Area - All objects, their corresponding instance variables & arrays are stored in heap. There is only 
	1 heap area in JVM. Method area & Heap area are shared b/w multiple threads hence these spaces are not 
	thread safe.
* Stack Area - There is 1 Stack Area per Thread. For every method call 1 entry is inserted in Stack Frame.
	All local variables are created in stack area. Stack area is thread-safe as it is not shared b/w Threads.
	Stack Frame is divided into further 3 parts -
	* Local Variable Array - All local variables of method & their values are stored here.
	* Operand Stack - If any intermdediate operation is to be performed it takes help of stack.
	Ex:- Let's say our method has 2 variables & it performs add method on it. Then initially
		* Stack is empty []
		* Then 1st local variable 5 gets added to Stack & Stack becomes [5]
		* Then 2nd local variable 6 gets added to Stack & Stack becomes [5, 6]
		* Then we get add operation, then it pops out 5 & 6 from stack, perform add operation & then stack becomes [11].
		& so on...
	* Frame Data - All symbols corresponding to methods are stored here. In case of exception, catch block info
		will be maintained here.
* PC Register - This is again 1 per thread, which holds address of currently executing instruction, once instruction
	is completed it is replaced with next instruction address.
* Native Method Stack - For every thread native method stack is maintained. It stores native method information.
	What is native method - A method which is written in some other language, like Java supports C & C++ integration.




https://www.geeksforgeeks.org/jvm-works-jvm-architecture/